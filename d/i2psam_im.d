/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 4.0.0
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
 * ----------------------------------------------------------------------------- */

module i2psam_im;
static import tango.stdc.config;

// Exception throwing support currently requires Tango, but there is no reason
// why it could not support Phobos.
static import tango.core.Exception;
static import tango.core.Thread;
static import tango.stdc.stringz;
static import tango.stdc.stringz;


private {
  version(linux) {
    version = Nix;
  } else version(darwin) {
    version = Nix;
  } else version(OSX) {
    version = Nix;
  } else version(FreeBSD) {
    version = Nix;
    version = freebsd;
  } else version(freebsd) {
    version = Nix;
  } else version(Unix) {
    version = Nix;
  } else version(Posix) {
    version = Nix;
  }

  version(Tango) {
    static import tango.stdc.string;
    static import tango.stdc.stringz;

    version (PhobosCompatibility) {
    } else {
      alias char[] string;
      alias wchar[] wstring;
      alias dchar[] dstring;
    }
  } else {
    version(D_Version2) {
      static import std.conv;
    }
    static import std.string;
    static import std.c.string;
  }

  version(D_Version2) {
    mixin("alias const(char)* CCPTR;");
  } else {
    alias char* CCPTR;
  }

  CCPTR swigToCString(string str) {
    version(Tango) {
      return tango.stdc.stringz.toStringz(str);
    } else {
      return std.string.toStringz(str);
    }
  }

  string swigToDString(CCPTR cstr) {
    version(Tango) {
      return tango.stdc.stringz.fromStringz(cstr);
    } else {
      version(D_Version2) {
        mixin("return std.conv.to!string(cstr);");
      } else {
        return std.c.string.toString(cstr);
      }
    }
  }
}

class SwigSwigSharedLibLoadException : Exception {
  this(in string[] libNames, in string[] reasons) {
    string msg = "Failed to load one or more shared libraries:";
    foreach(i, n; libNames) {
      msg ~= "\n\t" ~ n ~ " - ";
      if(i < reasons.length)
        msg ~= reasons[i];
      else
        msg ~= "Unknown";
    }
    super(msg);
  }
}

class SwigSymbolLoadException : Exception {
  this(string SwigSharedLibName, string symbolName) {
    super("Failed to load symbol " ~ symbolName ~ " from shared library " ~ SwigSharedLibName);
    _symbolName = symbolName;
  }

  string symbolName() {
    return _symbolName;
  }

private:
  string _symbolName;
}

private {
  version(Nix) {
    version(freebsd) {
      // the dl* functions are in libc on FreeBSD
    }
    else {
      pragma(lib, "dl");
    }

    version(Tango) {
      import tango.sys.Common;
    } else version(linux) {
      import std.c.linux.linux;
    } else {
      extern(C) {
        const RTLD_NOW = 2;

        void *dlopen(CCPTR file, int mode);
        int dlclose(void* handle);
        void *dlsym(void* handle, CCPTR name);
        CCPTR dlerror();
      }
    }

    alias void* SwigSharedLibHandle;

    SwigSharedLibHandle swigLoadSharedLib(string libName) {
      return dlopen(swigToCString(libName), RTLD_NOW);
    }

    void swigUnloadSharedLib(SwigSharedLibHandle hlib) {
      dlclose(hlib);
    }

    void* swigGetSymbol(SwigSharedLibHandle hlib, string symbolName) {
      return dlsym(hlib, swigToCString(symbolName));
    }

    string swigGetErrorStr() {
      CCPTR err = dlerror();
      if (err is null) {
        return "Unknown Error";
      }
      return swigToDString(err);
    }
  } else version(Windows) {
    alias ushort WORD;
    alias uint DWORD;
    alias CCPTR LPCSTR;
    alias void* HMODULE;
    alias void* HLOCAL;
    alias int function() FARPROC;
    struct VA_LIST {}

    extern (Windows) {
      HMODULE LoadLibraryA(LPCSTR);
      FARPROC GetProcAddress(HMODULE, LPCSTR);
      void FreeLibrary(HMODULE);
      DWORD GetLastError();
      DWORD FormatMessageA(DWORD, in void*, DWORD, DWORD, LPCSTR, DWORD, VA_LIST*);
      HLOCAL LocalFree(HLOCAL);
    }

    DWORD MAKELANGID(WORD p, WORD s) {
      return (((cast(WORD)s) << 10) | cast(WORD)p);
    }

    enum {
      LANG_NEUTRAL                    = 0,
      SUBLANG_DEFAULT                 = 1,
      FORMAT_MESSAGE_ALLOCATE_BUFFER  = 256,
      FORMAT_MESSAGE_IGNORE_INSERTS   = 512,
      FORMAT_MESSAGE_FROM_SYSTEM      = 4096
    }

    alias HMODULE SwigSharedLibHandle;

    SwigSharedLibHandle swigLoadSharedLib(string libName) {
      return LoadLibraryA(swigToCString(libName));
    }

    void swigUnloadSharedLib(SwigSharedLibHandle hlib) {
      FreeLibrary(hlib);
    }

    void* swigGetSymbol(SwigSharedLibHandle hlib, string symbolName) {
      return GetProcAddress(hlib, swigToCString(symbolName));
    }

    string swigGetErrorStr() {
      DWORD errcode = GetLastError();

      LPCSTR msgBuf;
      DWORD i = FormatMessageA(
        FORMAT_MESSAGE_ALLOCATE_BUFFER |
        FORMAT_MESSAGE_FROM_SYSTEM |
        FORMAT_MESSAGE_IGNORE_INSERTS,
        null,
        errcode,
        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        cast(LPCSTR)&msgBuf,
        0,
        null);

      string text = swigToDString(msgBuf);
      LocalFree(cast(HLOCAL)msgBuf);

      if (i >= 2) {
        i -= 2;
      }
      return text[0 .. i];
    }
  } else {
    static assert(0, "Operating system not supported by the wrapper loading code.");
  }

  final class SwigSharedLib {
    void load(string[] names) {
      if (_hlib !is null) return;

      string[] failedLibs;
      string[] reasons;

      foreach(n; names) {
        _hlib = swigLoadSharedLib(n);
        if (_hlib is null) {
          failedLibs ~= n;
          reasons ~= swigGetErrorStr();
          continue;
        }
        _name = n;
        break;
      }

      if (_hlib is null) {
        throw new SwigSwigSharedLibLoadException(failedLibs, reasons);
      }
    }

    void* loadSymbol(string symbolName, bool doThrow = true) {
      void* sym = swigGetSymbol(_hlib, symbolName);
      if(doThrow && (sym is null)) {
        throw new SwigSymbolLoadException(_name, symbolName);
      }
      return sym;
    }

    void unload() {
      if(_hlib !is null) {
        swigUnloadSharedLib(_hlib);
        _hlib = null;
      }
    }

  private:
    string _name;
    SwigSharedLibHandle _hlib;
  }
}

static this() {
  string[] possibleFileNames;
  version (Posix) {
    version (OSX) {
      possibleFileNames ~= ["libi2psam_wrap.dylib", "libi2psam_wrap.bundle"];
    }
    possibleFileNames ~= ["libi2psam_wrap.so"];
  } else version (Windows) {
    possibleFileNames ~= ["i2psam_wrap.dll", "libi2psam_wrap.so"];
  } else {
    static assert(false, "Operating system not supported by the wrapper loading code.");
  }

  auto library = new SwigSharedLib;
  library.load(possibleFileNames);

  string bindCode(string functionPointer, string symbol) {
    return functionPointer ~ " = cast(typeof(" ~ functionPointer ~
      "))library.loadSymbol(`" ~ symbol ~ "`);";
  }

  //#if !defined(SWIG_D_NO_EXCEPTION_HELPER)
  mixin(bindCode("swigRegisterExceptionCallbacksi2psam", "SWIGRegisterExceptionCallbacks_i2psam"));
  //#endif // SWIG_D_NO_EXCEPTION_HELPER
  //#if !defined(SWIG_D_NO_STRING_HELPER)
  mixin(bindCode("swigRegisterStringCallbacki2psam", "SWIGRegisterStringCallback_i2psam"));
  //#endif // SWIG_D_NO_STRING_HELPER
  
  mixin(bindCode("SAM_DEFAULT_ADDRESS_get", "D_SAM_DEFAULT_ADDRESS_get"));
  mixin(bindCode("SAM_DEFAULT_PORT_get", "D_SAM_DEFAULT_PORT_get"));
  mixin(bindCode("SAM_GENERATE_MY_DESTINATION_get", "D_SAM_GENERATE_MY_DESTINATION_get"));
  mixin(bindCode("SAM_MY_NAME_get", "D_SAM_MY_NAME_get"));
  mixin(bindCode("SAM_DEFAULT_I2P_OPTIONS_get", "D_SAM_DEFAULT_I2P_OPTIONS_get"));
  mixin(bindCode("SAM_SIGNATURE_TYPE_get", "D_SAM_SIGNATURE_TYPE_get"));
  mixin(bindCode("SAM_NAME_INBOUND_QUANTITY_get", "D_SAM_NAME_INBOUND_QUANTITY_get"));
  mixin(bindCode("SAM_DEFAULT_INBOUND_QUANTITY_get", "D_SAM_DEFAULT_INBOUND_QUANTITY_get"));
  mixin(bindCode("SAM_NAME_INBOUND_LENGTH_get", "D_SAM_NAME_INBOUND_LENGTH_get"));
  mixin(bindCode("SAM_DEFAULT_INBOUND_LENGTH_get", "D_SAM_DEFAULT_INBOUND_LENGTH_get"));
  mixin(bindCode("SAM_NAME_INBOUND_LENGTHVARIANCE_get", "D_SAM_NAME_INBOUND_LENGTHVARIANCE_get"));
  mixin(bindCode("SAM_DEFAULT_INBOUND_LENGTHVARIANCE_get", "D_SAM_DEFAULT_INBOUND_LENGTHVARIANCE_get"));
  mixin(bindCode("SAM_NAME_INBOUND_BACKUPQUANTITY_get", "D_SAM_NAME_INBOUND_BACKUPQUANTITY_get"));
  mixin(bindCode("SAM_DEFAULT_INBOUND_BACKUPQUANTITY_get", "D_SAM_DEFAULT_INBOUND_BACKUPQUANTITY_get"));
  mixin(bindCode("SAM_NAME_INBOUND_ALLOWZEROHOP_get", "D_SAM_NAME_INBOUND_ALLOWZEROHOP_get"));
  mixin(bindCode("SAM_NAME_INBOUND_IPRESTRICTION_get", "D_SAM_NAME_INBOUND_IPRESTRICTION_get"));
  mixin(bindCode("SAM_DEFAULT_INBOUND_IPRESTRICTION_get", "D_SAM_DEFAULT_INBOUND_IPRESTRICTION_get"));
  mixin(bindCode("SAM_NAME_OUTBOUND_QUANTITY_get", "D_SAM_NAME_OUTBOUND_QUANTITY_get"));
  mixin(bindCode("SAM_DEFAULT_OUTBOUND_QUANTITY_get", "D_SAM_DEFAULT_OUTBOUND_QUANTITY_get"));
  mixin(bindCode("SAM_NAME_OUTBOUND_LENGTH_get", "D_SAM_NAME_OUTBOUND_LENGTH_get"));
  mixin(bindCode("SAM_DEFAULT_OUTBOUND_LENGTH_get", "D_SAM_DEFAULT_OUTBOUND_LENGTH_get"));
  mixin(bindCode("SAM_NAME_OUTBOUND_LENGTHVARIANCE_get", "D_SAM_NAME_OUTBOUND_LENGTHVARIANCE_get"));
  mixin(bindCode("SAM_DEFAULT_OUTBOUND_LENGTHVARIANCE_get", "D_SAM_DEFAULT_OUTBOUND_LENGTHVARIANCE_get"));
  mixin(bindCode("SAM_NAME_OUTBOUND_BACKUPQUANTITY_get", "D_SAM_NAME_OUTBOUND_BACKUPQUANTITY_get"));
  mixin(bindCode("SAM_DEFAULT_OUTBOUND_BACKUPQUANTITY_get", "D_SAM_DEFAULT_OUTBOUND_BACKUPQUANTITY_get"));
  mixin(bindCode("SAM_NAME_OUTBOUND_ALLOWZEROHOP_get", "D_SAM_NAME_OUTBOUND_ALLOWZEROHOP_get"));
  mixin(bindCode("SAM_NAME_OUTBOUND_IPRESTRICTION_get", "D_SAM_NAME_OUTBOUND_IPRESTRICTION_get"));
  mixin(bindCode("SAM_DEFAULT_OUTBOUND_IPRESTRICTION_get", "D_SAM_DEFAULT_OUTBOUND_IPRESTRICTION_get"));
  mixin(bindCode("SAM_NAME_OUTBOUND_PRIORITY_get", "D_SAM_NAME_OUTBOUND_PRIORITY_get"));
  mixin(bindCode("SOCKET_ERROR_get", "D_SOCKET_ERROR_get"));
  mixin(bindCode("MAX_PATH_get", "D_MAX_PATH_get"));
  mixin(bindCode("MSG_NOSIGNAL_get", "D_MSG_NOSIGNAL_get"));
  mixin(bindCode("PRIO_MAX_get", "D_PRIO_MAX_get"));
  mixin(bindCode("THREAD_PRIORITY_LOWEST_get", "D_THREAD_PRIORITY_LOWEST_get"));
  mixin(bindCode("THREAD_PRIORITY_BELOW_NORMAL_get", "D_THREAD_PRIORITY_BELOW_NORMAL_get"));
  mixin(bindCode("THREAD_PRIORITY_NORMAL_get", "D_THREAD_PRIORITY_NORMAL_get"));
  mixin(bindCode("THREAD_PRIORITY_ABOVE_NORMAL_get", "D_THREAD_PRIORITY_ABOVE_NORMAL_get"));
  mixin(bindCode("strnlen_int", "D_strnlen_int"));
  mixin(bindCode("i2psam_stream_settings_samhost_set", "D_i2psam_stream_settings_samhost_set"));
  mixin(bindCode("i2psam_stream_settings_samhost_get", "D_i2psam_stream_settings_samhost_get"));
  mixin(bindCode("i2psam_stream_settings_samport_get", "D_i2psam_stream_settings_samport_get"));
  mixin(bindCode("i2psam_stream_settings_nickname_set", "D_i2psam_stream_settings_nickname_set"));
  mixin(bindCode("i2psam_stream_settings_nickname_get", "D_i2psam_stream_settings_nickname_get"));
  mixin(bindCode("i2psam_stream_settings_i2cp_opts_set", "D_i2psam_stream_settings_i2cp_opts_set"));
  mixin(bindCode("i2psam_stream_settings_i2cp_opts_get", "D_i2psam_stream_settings_i2cp_opts_get"));
  mixin(bindCode("i2psam_stream_settings_destination_set", "D_i2psam_stream_settings_destination_set"));
  mixin(bindCode("i2psam_stream_settings_destination_get", "D_i2psam_stream_settings_destination_get"));
  mixin(bindCode("new_i2psam_stream_settings", "D_new_i2psam_stream_settings"));
  mixin(bindCode("delete_i2psam_stream_settings", "D_delete_i2psam_stream_settings"));
  mixin(bindCode("i2psam_stream_session_new", "D_i2psam_stream_session_new"));
  mixin(bindCode("i2psam_stream_session_free", "D_i2psam_stream_session_free"));
  mixin(bindCode("i2psam_get_samhost", "D_i2psam_get_samhost"));
  mixin(bindCode("i2psam_get_samport", "D_i2psam_get_samport"));
  mixin(bindCode("i2psam_get_nickname", "D_i2psam_get_nickname"));
  mixin(bindCode("i2psam_get_session_id", "D_i2psam_get_session_id"));
  mixin(bindCode("i2psam_get_sam_min_version", "D_i2psam_get_sam_min_version"));
  mixin(bindCode("i2psam_get_sam_max_version", "D_i2psam_get_sam_max_version"));
  mixin(bindCode("i2psam_get_sam_version", "D_i2psam_get_sam_version"));
  mixin(bindCode("i2psam_get_i2cp_options", "D_i2psam_get_i2cp_options"));
  mixin(bindCode("i2psam_is_sick", "D_i2psam_is_sick"));
  mixin(bindCode("i2psam_accept", "D_i2psam_accept"));
  mixin(bindCode("i2psam_connect", "D_i2psam_connect"));
  mixin(bindCode("i2psam_forward", "D_i2psam_forward"));
  mixin(bindCode("i2psam_namelookup", "D_i2psam_namelookup"));
  mixin(bindCode("i2psam_dest_generate", "D_i2psam_dest_generate"));
  mixin(bindCode("i2psam_stop_forwarding", "D_i2psam_stop_forwarding"));
  mixin(bindCode("i2psam_stop_forwarding_all", "D_i2psam_stop_forwarding_all"));
  mixin(bindCode("i2psam_get_my_destination", "D_i2psam_get_my_destination"));
  mixin(bindCode("i2psam_write", "D_i2psam_write"));
  mixin(bindCode("i2psam_read", "D_i2psam_read"));
  mixin(bindCode("i2psam_socket_close", "D_i2psam_socket_close"));
  mixin(bindCode("i2psam_socket_is_ok", "D_i2psam_socket_is_ok"));
  mixin(bindCode("i2psam_socket_free", "D_i2psam_socket_free"));
  mixin(bindCode("i2psam_destination_priv", "D_i2psam_destination_priv"));
  mixin(bindCode("i2psam_destination_pub", "D_i2psam_destination_pub"));
  mixin(bindCode("i2psam_destination_free", "D_i2psam_destination_free"));
}

//#if !defined(SWIG_D_NO_EXCEPTION_HELPER)
extern(C) void function(
  SwigExceptionCallback exceptionCallback,
  SwigExceptionCallback illegalArgumentCallback,
  SwigExceptionCallback illegalElementCallback,
  SwigExceptionCallback ioCallback,
  SwigExceptionCallback noSuchElementCallback) swigRegisterExceptionCallbacksi2psam;
//#endif // SWIG_D_NO_EXCEPTION_HELPER

//#if !defined(SWIG_D_NO_STRING_HELPER)
extern(C) void function(SwigStringCallback callback) swigRegisterStringCallbacki2psam;
//#endif // SWIG_D_NO_STRING_HELPER


template SwigOperatorDefinitions() {
  public override int opEquals(Object o) {
    if (auto rhs = cast(typeof(this))o) {
      if (swigCPtr == rhs.swigCPtr) return 1;
      static if (is(typeof(swigOpEquals(rhs)))) {
        return swigOpEquals(rhs) ? 1 : 0;
      } else {
        return 0; 
      }
    }
    return super.opEquals(o);
  }


}


private class SwigExceptionHelper {
  static this() {
    swigRegisterExceptionCallbacksi2psam(
      &setException,
      &setIllegalArgumentException,
      &setIllegalElementException,
      &setIOException,
      &setNoSuchElementException);
  }

  static void setException(char* message) {
    auto exception = new object.Exception(tango.stdc.stringz.fromStringz(message).dup);
    SwigPendingException.set(exception);
  }

  static void setIllegalArgumentException(char* message) {
    auto exception = new tango.core.Exception.IllegalArgumentException(tango.stdc.stringz.fromStringz(message).dup);
    SwigPendingException.set(exception);
  }

  static void setIllegalElementException(char* message) {
    auto exception = new tango.core.Exception.IllegalElementException(tango.stdc.stringz.fromStringz(message).dup);
    SwigPendingException.set(exception);
  }

  static void setIOException(char* message) {
    auto exception = new tango.core.Exception.IOException(tango.stdc.stringz.fromStringz(message).dup);
    SwigPendingException.set(exception);
  }

  static void setNoSuchElementException(char* message) {
    auto exception = new tango.core.Exception.NoSuchElementException(tango.stdc.stringz.fromStringz(message).dup);
    SwigPendingException.set(exception);
  }
}

package class SwigPendingException {
public:
  static this() {
    m_sPendingException = new ThreadLocalData(null);
  }

  static bool isPending() {
    return m_sPendingException.val !is null;
  }

  static void set(object.Exception e) {
    auto pending = m_sPendingException.val;
    if (pending !is null) {
      e.next = pending;
      throw new object.Exception("FATAL: An earlier pending exception from C/C++ " ~
        "code was missed and thus not thrown (" ~ pending.classinfo.name ~ ": " ~
        pending.msg ~ ")!", e);
    }
    m_sPendingException.val = e;
  }

  static object.Exception retrieve() {
    auto e = m_sPendingException.val;
    m_sPendingException.val = null;
    return e;
  }

private:
  // The reference to the pending exception (if any) is stored thread-local.
  alias tango.core.Thread.ThreadLocal!(object.Exception) ThreadLocalData;
  static ThreadLocalData m_sPendingException;
}
alias void function(char* message) SwigExceptionCallback;


private class SwigStringHelper {
  static this() {
    swigRegisterStringCallbacki2psam(&createString);
  }

  static char* createString(char* cString) {
    // We are effectively dup'ing the string here.
    return tango.stdc.stringz.toStringz(tango.stdc.stringz.fromStringz(cString));
  }
}
alias char* function(char* cString) SwigStringCallback;


template SwigExternC(T) {
  static if (is(typeof(*(T.init)) R == return)) {
    static if (is(typeof(*(T.init)) P == function)) {
      alias extern(C) R function(P) SwigExternC;
    }
  }
}

SwigExternC!(char* function()) SAM_DEFAULT_ADDRESS_get;
SwigExternC!(int function()) SAM_DEFAULT_PORT_get;
SwigExternC!(char* function()) SAM_GENERATE_MY_DESTINATION_get;
SwigExternC!(char* function()) SAM_MY_NAME_get;
SwigExternC!(char* function()) SAM_DEFAULT_I2P_OPTIONS_get;
SwigExternC!(char* function()) SAM_SIGNATURE_TYPE_get;
SwigExternC!(char* function()) SAM_NAME_INBOUND_QUANTITY_get;
SwigExternC!(int function()) SAM_DEFAULT_INBOUND_QUANTITY_get;
SwigExternC!(char* function()) SAM_NAME_INBOUND_LENGTH_get;
SwigExternC!(int function()) SAM_DEFAULT_INBOUND_LENGTH_get;
SwigExternC!(char* function()) SAM_NAME_INBOUND_LENGTHVARIANCE_get;
SwigExternC!(int function()) SAM_DEFAULT_INBOUND_LENGTHVARIANCE_get;
SwigExternC!(char* function()) SAM_NAME_INBOUND_BACKUPQUANTITY_get;
SwigExternC!(int function()) SAM_DEFAULT_INBOUND_BACKUPQUANTITY_get;
SwigExternC!(char* function()) SAM_NAME_INBOUND_ALLOWZEROHOP_get;
SwigExternC!(char* function()) SAM_NAME_INBOUND_IPRESTRICTION_get;
SwigExternC!(int function()) SAM_DEFAULT_INBOUND_IPRESTRICTION_get;
SwigExternC!(char* function()) SAM_NAME_OUTBOUND_QUANTITY_get;
SwigExternC!(int function()) SAM_DEFAULT_OUTBOUND_QUANTITY_get;
SwigExternC!(char* function()) SAM_NAME_OUTBOUND_LENGTH_get;
SwigExternC!(int function()) SAM_DEFAULT_OUTBOUND_LENGTH_get;
SwigExternC!(char* function()) SAM_NAME_OUTBOUND_LENGTHVARIANCE_get;
SwigExternC!(int function()) SAM_DEFAULT_OUTBOUND_LENGTHVARIANCE_get;
SwigExternC!(char* function()) SAM_NAME_OUTBOUND_BACKUPQUANTITY_get;
SwigExternC!(int function()) SAM_DEFAULT_OUTBOUND_BACKUPQUANTITY_get;
SwigExternC!(char* function()) SAM_NAME_OUTBOUND_ALLOWZEROHOP_get;
SwigExternC!(char* function()) SAM_NAME_OUTBOUND_IPRESTRICTION_get;
SwigExternC!(int function()) SAM_DEFAULT_OUTBOUND_IPRESTRICTION_get;
SwigExternC!(char* function()) SAM_NAME_OUTBOUND_PRIORITY_get;
SwigExternC!(int function()) SOCKET_ERROR_get;
SwigExternC!(int function()) MAX_PATH_get;
SwigExternC!(int function()) MSG_NOSIGNAL_get;
SwigExternC!(int function()) PRIO_MAX_get;
SwigExternC!(int function()) THREAD_PRIORITY_LOWEST_get;
SwigExternC!(int function()) THREAD_PRIORITY_BELOW_NORMAL_get;
SwigExternC!(int function()) THREAD_PRIORITY_NORMAL_get;
SwigExternC!(int function()) THREAD_PRIORITY_ABOVE_NORMAL_get;
SwigExternC!(size_t function(char* jarg1, size_t jarg2)) strnlen_int;
SwigExternC!(void function(void* jarg1, char* jarg2)) i2psam_stream_settings_samhost_set;
SwigExternC!(char* function(void* jarg1)) i2psam_stream_settings_samhost_get;
SwigExternC!(void* function(void* jarg1)) i2psam_stream_settings_samport_get;
SwigExternC!(void function(void* jarg1, char* jarg2)) i2psam_stream_settings_nickname_set;
SwigExternC!(char* function(void* jarg1)) i2psam_stream_settings_nickname_get;
SwigExternC!(void function(void* jarg1, char* jarg2)) i2psam_stream_settings_i2cp_opts_set;
SwigExternC!(char* function(void* jarg1)) i2psam_stream_settings_i2cp_opts_get;
SwigExternC!(void function(void* jarg1, char* jarg2)) i2psam_stream_settings_destination_set;
SwigExternC!(char* function(void* jarg1)) i2psam_stream_settings_destination_get;
SwigExternC!(void* function()) new_i2psam_stream_settings;
SwigExternC!(void function(void* jarg1)) delete_i2psam_stream_settings;
SwigExternC!(void* function(void* jarg1)) i2psam_stream_session_new;
SwigExternC!(void function(void* jarg1)) i2psam_stream_session_free;
SwigExternC!(char* function(void* jarg1)) i2psam_get_samhost;
SwigExternC!(void* function(void* jarg1)) i2psam_get_samport;
SwigExternC!(char* function(void* jarg1)) i2psam_get_nickname;
SwigExternC!(char* function(void* jarg1)) i2psam_get_session_id;
SwigExternC!(char* function(void* jarg1)) i2psam_get_sam_min_version;
SwigExternC!(char* function(void* jarg1)) i2psam_get_sam_max_version;
SwigExternC!(char* function(void* jarg1)) i2psam_get_sam_version;
SwigExternC!(char* function(void* jarg1)) i2psam_get_i2cp_options;
SwigExternC!(int function(void* jarg1)) i2psam_is_sick;
SwigExternC!(void* function(void* jarg1, int jarg2)) i2psam_accept;
SwigExternC!(void* function(void* jarg1, char* jarg2, int jarg3)) i2psam_connect;
SwigExternC!(int function(void* jarg1, char* jarg2, void* jarg3, int jarg4)) i2psam_forward;
SwigExternC!(char* function(void* jarg1, char* jarg2)) i2psam_namelookup;
SwigExternC!(void* function(void* jarg1)) i2psam_dest_generate;
SwigExternC!(void function(void* jarg1, char* jarg2, void* jarg3)) i2psam_stop_forwarding;
SwigExternC!(void function(void* jarg1)) i2psam_stop_forwarding_all;
SwigExternC!(void* function(void* jarg1)) i2psam_get_my_destination;
SwigExternC!(void function(void* jarg1, char* jarg2, size_t jarg3)) i2psam_write;
SwigExternC!(char* function(void* jarg1, void* jarg2)) i2psam_read;
SwigExternC!(void function(void* jarg1)) i2psam_socket_close;
SwigExternC!(int function(void* jarg1)) i2psam_socket_is_ok;
SwigExternC!(void function(void* jarg1)) i2psam_socket_free;
SwigExternC!(char* function(void* jarg1)) i2psam_destination_priv;
SwigExternC!(char* function(void* jarg1)) i2psam_destination_pub;
SwigExternC!(void function(void* jarg1)) i2psam_destination_free;
